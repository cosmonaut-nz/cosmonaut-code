File: /Users/avastmick/repos/cipher-crypt/src/affine.rs
Review:
Here are some observations about the code provided:

1. In the `new` method of `Affine`, the panic message for the keys being out of range could potentially be split into separate checks for `a` and `b` to provide more specific error messages indicating which parameter is out of range.

2. The `encrypt` and `decrypt` methods use the `unwrap` method on the results of the inner encryption and decryption logic. This could result in a panic if an error occurs inside the `shift_substitution` function, which might not be the intended behavior. It's generally good practice to propagate errors to allow calling code to handle them appropriately unless a panic is truly warranted.

3. The test case `fn b_shares_factor()` is named misleadingly because the function name suggests testing if `b` shares a factor with 26, which is not something the code checks for. It only checks that condition for `a`.

4. In the `encrypt` method comment, you define `E(x) = (ax + b) mod 26`. The range check in the `new` method allows `a` and `b` to be exactly 26, but if `b` were 26 then `(ax + b) mod 26` would always be the same as `ax mod 26`, essentially ignoring the addition of `b`. This is not an error but may be an unnecessary allowance because such a key would be weaker. It should be documented as expected behavior or the range check should be adjusted to exclude 26 from valid `b` values.

5. The encryption and decryption examples provided in the comments do not correspond to an actual Affine cipher transformation result, and since the actual `shift_substitution` and `STANDARD.modulo` functions are not shown, it’s not possible to verify within the scope of this review if the assertions are indeed correct. These examples would typically be matched to the expected behavior of a correctly implemented Affine cipher algorithm.

6. The tests do not cover all edge cases. For instance, it may be worthwhile to test cases where the message contains numbers, punctuation, or special characters that are not part of the alphabet to see how the cipher handles them.

7. The `with_utf8` test is somewhat misleading because it asserts the encrypted and then decrypted message is equal to the original message with non-alphabetic characters included. The way these characters are handled by the `encrypt` and `decrypt` methods isn't clear from the code snippet provided, as the behavior is determined by the implementation of `shift_substitution` and how it interacts with characters not in the cipher's alphabet.

Please also note that my observations are based on the assumption about typical behavior of Affine cipher and conventional coding practices. Without information about the actual implementation and behavior of the omitted functions (`alphabet::STANDARD.modulo`, `alphabet::STANDARD.multiplicative_inverse`, substitute::shift_substitution`, and the `Cipher` trait), the ability to provide a comprehensive review is limited.

File: /Users/avastmick/repos/cipher-crypt/src/rot13.rs
Review:
The code given defines `encrypt` and `decrypt` functions for the ROT13 cipher and provides some tests. However, ROT13 encryption and decryption are identical operations, as shifting by 13 places again in a 26-letter alphabet results in the original text. Thus, the `encrypt` and `decrypt` functions should be identical, as they are in the code.

However, the handling of non-alphabetic characters (especially UTF-8 encoded characters like emojis) is not explicitly mentioned or handled in this implementation. ROT13 is traditionally defined only for alphabetic characters, and other characters are usually left unchanged. The code relies on the internal implementation of `substitute::shift_substitution` and `alphabet::STANDARD.modulo` to correctly handle such cases, and any deviation there could lead to incorrect results, as ROT13 should not modify non-alphabetic characters.

Here are a few points for consideration:

1. Avoid Redundancy: Since ROT13 encryption and decryption are identical, you could eliminate redundancy by having one function, say `rot13`, which performs the transformation.

2. UTF-8 handling in tests: The `with_utf8` test implies that the function correctly handles UTF-8 encoded characters such as emojis, but it's not clear from this snippet how `substitute::shift_substitution` and `alphabet::STANDARD.modulo` manage these characters. You need to ensure that these methods are designed to leave non-alphabetic characters unchanged, as per the ROT13 design.

3. Documentation mismatch: If the `substitute::shift_substitution` or `alphabet::STANDARD.modulo` does not correctly handle non-alphabetic characters, the comments should explicitly state how non-standard characters are handled or include additional code to handle such cases.

4. Test Cases: The provided test cases check for round-trip encryption and decryption. Still, they do not test the transformation's correctness itself (e.g., that 'a' becomes 'n', 'n' becomes 'a', etc.). Additional test cases should verify that the correct transformation is applied to individual characters.

5. Error handling: Depending on the behavior of `substitute::shift_substitution` and `alphabet::STANDARD.modulo`, if they don't already manage errors when faced with unexpected inputs like non-alphabetic characters, the code may need to add error handling logic to manage these scenarios safely.

6. Performance: While performance may not be critical for such a simple cipher, it's worth noting that for very large messages, the performance of the `shift_substitution` could be a factor. It would be important to ensure that it operates efficiently.

Remember that suggestions for improvements depend on the context and intended use of the code -- for example, whether it's important to handle Unicode characters or not -- as well as on details of how `substitute::shift_substitution` and `alphabet::STANDARD.modulo` are implemented, which are not included in the snippet.

File: /Users/avastmick/repos/cipher-crypt/src/adfgvx.rs
Review:
This code appears to be mostly correct as per the Rust syntax and structuring norms. However, while the logic and implementation cannot be judged without understanding the broader context, there are a few potential improvements and considerations based on Rust idioms and best practices:

1. **Unnecessary `String` Allocation**: In the test cases, instead of creating a `String` from a string literal, you can just pass the string literal directly since the `new` function expects a `String` and Rust will automatically convert the literal to a `String`.

2. **Documentation Comments**: There's an inconsistency where `it's` is used instead of `its` in the documentation comments.

3. **Unnecessary use of `concat!`**: In the tests, the use of `concat!` can be avoided because string literals adjacent to each other are automatically concatenated by the Rust compiler. It's more idiomatic and readable to just write out the literal directly when it's broken across lines.

4. **Misleading Comments**: Some comments indicate specific behaviors or features (such as spaces being used as padding or specifics of version 0.11.0) which cannot be verified as correct or relevant without additional context. Ensure that comments are kept accurate and up-to-date to avoid confusion.

5. **Test Cases and Error Handling**: The test cases show encryption and decryption, including with padding characters. However, without the implementation details for `Polybius` and `ColumnarTransposition`, it's not possible to assert if the error handling is done correctly. Normally, error handling should include meaningful error messages rather than panics, which are visible to the users of your crate (unless a panic is indeed justified in the case of an unrecoverable error).

6. **Panic Conditions**: The documentation mentions that panic occurs if a non-alphanumeric symbol is part of the key. However, there is no code here that explicitly checks for this and panics; so, either there should be a check and panic or the documentation should be updated if this is handled elsewhere (e.g., within `Polybius::new` or `ColumnarTransposition::new`).

7. **Use of `unwrap` in Tests**: Tests frequently use `unwrap()` which is fine for test cases. However, more comprehensive testing would also include tests for error cases and making sure the correct errors are emitted.

8. **UTF-8 Support**: The last two tests imply the cipher supports encrypting/decrypting UTF-8 characters like emojis. Unless the `Polybius` and `ColumnarTransposition` ciphers can truly support the full range of UTF-8 characters, this might be misleading. A typical Adfgvx cipher would be expected to support a limited character set.

9. **Test Case Naming**: Test case names should be more descriptive to reflect what specifically they are testing. For example, `simple_with_padding` could be more descriptive—does it deal with padding in the plaintext, padding in the ciphertext, or padding characters in keys?

Please review these points in the context of the complete codebase, including the modules and functions not shown here, to improve code quality and maintainability.

